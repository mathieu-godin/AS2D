/*
Sprite.cs
---------

Par Mathieu Godin

Rôle : Composant qui est un DrawableGameComponent et
       hérite de ICollisionnable, permet d'afficher
       un sprite à l'écran par le biais d'un Texture2D

Créé : 5 octobre 2016
Modifié : 12 octobre 2016
Description : Affiche maintenant à l'échelle et EstEnCollision a été implanté

Co-auteur : Raphaël Brulé
*/
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;


namespace AtelierXNA
{
    /// <summary>
    /// Classe sprite qui englobe la plupart des composants de ce projet
    /// </summary>
    public class Sprite : Microsoft.Xna.Framework.DrawableGameComponent, ICollisionable
    {
        protected const int ORDONNÉE_NULLE = 0, ABSCISSE_NULLE = 0, HAUTEUR_NULLE = 0, LARGEUR_NULLE = 0, DIVISEUR_OBTENTION_DEMI_GRANDEUR = 2, ORIGINE = 0;

        //Propriétés initialement gérées par le constructeur
        string NomImage { get; set; }
        public Vector2 Position { get; private set; }
        protected Rectangle ZoneAffichage { get; set; }

        protected Rectangle RectangleSource { get; set; }
        protected Vector2 DimensionsImageÀLAffichage { get; set; }
        protected SpriteBatch GestionSprites { get; set; }
        protected RessourcesManager<Texture2D> GestionnaireDeTextures { get; set; }
        /* probably private */ protected Texture2D Image { get; set; }
        protected float Échelle { get; set; }
        //Vector2 Origine { get; set; }
        protected Rectangle RectangleDimensionsImageÀLÉchelle { get; set; }
        protected int MargeDroite { get; set; }
        protected int MargeBas { get; set; }
        protected int MargeGauche { get; set; }
        protected int MargeHaut { get; set; }

        /// <summary>
        /// Constructeur de la classe Sprite
        /// </summary>
        /// <param name="jeu">Jeu de type Game</param>
        /// <param name="nomImage">Nom de l'image tel qu'écrit dans son répertoire</param>
        /// <param name="position">Position à laquelle on veut placer le sprite</param>
        /// <param name="zoneAffichage">Zone d'affichage dans laquelle on met le sprite</param>
        public Sprite(Game jeu, string nomImage, Vector2 position, Rectangle zoneAffichage) : base(jeu)
        {
            NomImage = nomImage;
            Position = position;
            ZoneAffichage = zoneAffichage;
        }

        /// <summary>
        /// Initialise ce qu'il faut pour le sprite
        /// </summary>
        public override void Initialize()
        {
            base.Initialize();
            DimensionsImageÀLAffichage = new Vector2(Image.Width, Image.Height);
            RectangleSource = CréerRectangleSource();
            Échelle = CalculerÉchelle();
            //Origine = new Vector2(ABSCISSE_NULLE, ORDONNÉE_NULLE);
            RectangleDimensionsImageÀLÉchelle = CréerRectangleDimensionsImageÀLÉchelle();
            MargeHaut = HAUTEUR_NULLE;
            MargeGauche = LARGEUR_NULLE;
        }

        /// <summary>
        /// Créer rectangle source
        /// </summary>
        /// <returns>Retourne le rectangle en question</returns>
        protected virtual Rectangle CréerRectangleSource()
        {
            return new Rectangle(ORIGINE, ORIGINE, (int)DimensionsImageÀLAffichage.X, (int)DimensionsImageÀLAffichage.Y);
        }

        /// <summary>
        /// Céer le rectangle des bonnes dimmensions à l'échelle et position d'affichage
        /// </summary>
        /// <returns>Retourne le rectangle en question</returns>
        protected virtual Rectangle CréerRectangleDimensionsImageÀLÉchelle()
        {
            return new Rectangle((int)Position.X, (int)Position.Y, (int)(DimensionsImageÀLAffichage.X * Échelle), (int)(DimensionsImageÀLAffichage.Y * Échelle));
        }

        /// <summary>
        /// Calcule l'échelle en calculant l'échelle horizontale et verticale et prenant la plus petite des deux
        /// </summary>
        /// <returns>La plus petite des échelles horizontales et verticales</returns>
        protected virtual float CalculerÉchelle()
        {
            //Rajout de cast de float car sinon ca fesait une division entière qui donnait tj 0! Mais anyway cest pas bon mais bon, va voir le remix dans SpriteAnimé LOL.
            float échelleHorizontale = ZoneAffichage.Width / (float)Image.Width, échelleVerticale = ZoneAffichage.Height / (float)Image.Height;

            return échelleHorizontale < échelleVerticale ? échelleHorizontale : échelleVerticale;
        }

        /// <summary>
        /// Charge le contenu nécessaire au fonctionnement du Sprite
        /// </summary>
        protected override void LoadContent()
        {
            GestionSprites = Game.Services.GetService(typeof(SpriteBatch)) as SpriteBatch;
            GestionnaireDeTextures = Game.Services.GetService(typeof(RessourcesManager<Texture2D>)) as RessourcesManager<Texture2D>;
            Image = GestionnaireDeTextures.Find(NomImage);
            CalculerMarges();
        }

        /// <summary>
        /// Méthode qui dessine le SpriteAnimé à l'écran
        /// </summary>
        /// <param name="gameTime">Objet contenant l'information de temps de jeu de type GameTime</param>
        public override void Draw(GameTime gameTime)
        {
            GestionSprites.Draw(Image, RectangleDimensionsImageÀLÉchelle, RectangleSource, Color.White);
        }

        /// <summary>
        /// Prédicat vrai si le Sprite est en collision avec un autre objet
        /// </summary>
        /// <param name="autreObjet"></param>
        /// <returns></returns>
        public virtual bool EstEnCollision(object autreObjet)
        {
            //SpriteAnimé autreSprite = (SpriteAnimé)autreObjet;
            //Rectangle rectangleCollision = Rectangle.Intersect(RectangleDimensionsImageÀLÉchelle, autreSprite.RectangleDimensionsImageÀLÉchelle);
            //bool collision = rectangleCollision.Width == LARGEUR_NULLE && rectangleCollision.Height == HAUTEUR_NULLE;

            //autreSprite.ADétruire = collision;
            //return collision;

            //Rectangle autreRectangle = ((SpriteAnimé)autreObjet).DestinationRectangle;

            //return ZoneAffichage.Intersects(autreRectangle);

            return true;

        }

        /// <summary>
        /// Calcule les marges du sprite
        /// </summary>
        protected virtual void CalculerMarges()
        {
            MargeDroite = Game.Window.ClientBounds.Width - RectangleDimensionsImageÀLÉchelle.Width;
            MargeBas = Game.Window.ClientBounds.Height - RectangleDimensionsImageÀLÉchelle.Height;
        }


    }
}
